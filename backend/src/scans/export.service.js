/**
 * Export Service
 * Export scan results to PDF and CSV formats
 */

import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import { Scan } from './scan.model.js';
import logger from '../utils/logger.js';

/**
 * Generate PDF report for a scan
 * @param {string} scanId - Scan ID
 * @param {string} outputPath - Output file path
 * @returns {Promise<string>} Path to generated PDF
 */
export const exportScanToPDF = async (scanId, outputPath) => {
    try {
        const scan = await Scan.findById(scanId);
        if (!scan) {
            throw new Error('Scan not found');
        }

        const doc = new PDFDocument({ margin: 50 });
        const stream = fs.createWriteStream(outputPath);
        doc.pipe(stream);

        // Header
        doc.fontSize(24).font('Helvetica-Bold').text('Deepfake Detection Report', { align: 'center' });
        doc.moveDown();
        doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
        doc.moveDown(2);

        // Scan Information
        doc.fontSize(16).font('Helvetica-Bold').text('Scan Information');
        doc.moveDown(0.5);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Scan ID: ${scan._id}`);
        doc.text(`File Name: ${scan.fileName}`);
        doc.text(`Media Type: ${scan.mediaType}`);
        doc.text(`File Size: ${(scan.fileSize / 1024 / 1024).toFixed(2)} MB`);
        doc.text(`Timestamp: ${scan.createdAt.toLocaleString()}`);
        doc.text(`Operative: ${scan.operativeId}`);
        doc.moveDown();

        // Detection Results
        doc.fontSize(16).font('Helvetica-Bold').text('Detection Results');
        doc.moveDown(0.5);
        doc.fontSize(12).font('Helvetica-Bold');

        const verdict = scan.result?.verdict || scan.result?.status || 'UNKNOWN';
        const verdictColor = verdict === 'DEEPFAKE' ? 'red' : verdict === 'SUSPICIOUS' ? 'orange' : 'green';
        doc.fillColor(verdictColor).text(`Verdict: ${verdict}`);
        doc.fillColor('black');

        doc.fontSize(10).font('Helvetica');
        doc.text(`Risk Score: ${scan.result?.riskScore || 0}/100`);
        doc.text(`Confidence: ${scan.result?.confidence || 0}%`);
        doc.moveDown();

        // Detailed Scores
        doc.fontSize(14).font('Helvetica-Bold').text('Detailed Analysis');
        doc.moveDown(0.5);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Video Score: ${scan.result?.metadata?.facialMatch !== undefined ? (100 - scan.result.metadata.facialMatch) : 0}/100`);
        doc.text(`Audio Score: ${scan.result?.metadata?.audioMatch !== undefined ? (100 - scan.result.metadata.audioMatch) : 0}/100`);
        doc.text(`GAN Fingerprint: ${scan.result?.metadata?.ganFingerprint || 0}/100`);
        doc.text(`Temporal Consistency: ${scan.result?.metadata?.temporalConsistency || 0}/100`);
        doc.moveDown();

        // Metadata
        const perceptionData = scan.processingData?.perception;
        if (perceptionData?.metadata) {
            doc.fontSize(14).font('Helvetica-Bold').text('Media Metadata');
            doc.moveDown(0.5);
            doc.fontSize(10).font('Helvetica');
            if (perceptionData.metadata.codec) doc.text(`Codec: ${perceptionData.metadata.codec}`);
            if (perceptionData.metadata.bitrate) doc.text(`Bitrate: ${perceptionData.metadata.bitrate}`);
            if (perceptionData.metadata.resolution) doc.text(`Resolution: ${perceptionData.metadata.resolution}`);
            if (perceptionData.metadata.duration) doc.text(`Duration: ${perceptionData.metadata.duration}s`);
            if (perceptionData.metadata.fps) doc.text(`FPS: ${perceptionData.metadata.fps}`);
            doc.moveDown();
        }

        // GPS Coordinates
        if (scan.gpsCoordinates) {
            doc.fontSize(14).font('Helvetica-Bold').text('Location Data');
            doc.moveDown(0.5);
            doc.fontSize(10).font('Helvetica');
            doc.text(`Latitude: ${scan.gpsCoordinates.latitude}`);
            doc.text(`Longitude: ${scan.gpsCoordinates.longitude}`);
            doc.moveDown();
        }

        // Explanation
        const explanations = scan.result?.explanations;
        if (explanations && explanations.length > 0) {
            doc.fontSize(14).font('Helvetica-Bold').text('Analysis Explanation');
            doc.moveDown(0.5);
            doc.fontSize(10).font('Helvetica');
            doc.text(explanations.join('. '), { align: 'justify' });
            doc.moveDown();
        }

        // Footer
        doc.fontSize(8).font('Helvetica').text(
            'This report was generated by the Deepfake Detection & Authenticity Verification System',
            { align: 'center' }
        );

        doc.end();

        await new Promise((resolve, reject) => {
            stream.on('finish', resolve);
            stream.on('error', reject);
        });

        logger.info(`[EXPORT] PDF generated for scan ${scanId}: ${outputPath}`);
        return outputPath;
    } catch (error) {
        logger.error(`[EXPORT] Error generating PDF: ${error.message}`);
        throw error;
    }
};

/**
 * Export multiple scans to CSV
 * @param {Array<string>} scanIds - Array of scan IDs
 * @param {string} outputPath - Output file path
 * @returns {Promise<string>} Path to generated CSV
 */
export const exportScansToCSV = async (scanIds, outputPath) => {
    try {
        const scans = await Scan.find({ _id: { $in: scanIds } }).sort({ timestamp: -1 });

        if (scans.length === 0) {
            throw new Error('No scans found');
        }

        // CSV headers
        const headers = [
            'Scan ID',
            'File Name',
            'Media Type',
            'Verdict',
            'Risk Score',
            'Confidence',
            'Video Score',
            'Audio Score',
            'GAN Fingerprint',
            'Temporal Consistency',
            'File Size (MB)',
            'Timestamp',
            'Operative',
            'Latitude',
            'Longitude',
        ];

        // Build CSV content
        let csvContent = headers.join(',') + '\n';

        scans.forEach((scan) => {
            const row = [
                scan._id,
                `"${scan.fileName}"`,
                scan.mediaType,
                scan.result?.verdict || scan.result?.status || 'UNKNOWN',
                scan.result?.riskScore || 0,
                scan.result?.confidence || 0,
                scan.result?.metadata?.facialMatch !== undefined ? (100 - scan.result.metadata.facialMatch) : 0,
                scan.result?.metadata?.audioMatch !== undefined ? (100 - scan.result.metadata.audioMatch) : 0,
                scan.result?.metadata?.ganFingerprint || 0,
                scan.result?.metadata?.temporalConsistency || 0,
                (scan.fileSize / 1024 / 1024).toFixed(2),
                scan.createdAt.toISOString(),
                `"${scan.operativeId}"`,
                scan.gpsCoordinates?.latitude || '',
                scan.gpsCoordinates?.longitude || '',
            ];
            csvContent += row.join(',') + '\n';
        });

        // Write to file
        fs.writeFileSync(outputPath, csvContent, 'utf-8');

        logger.info(`[EXPORT] CSV generated for ${scans.length} scans: ${outputPath}`);
        return outputPath;
    } catch (error) {
        logger.error(`[EXPORT] Error generating CSV: ${error.message}`);
        throw error;
    }
};

/**
 * Export scan history to CSV
 * @param {Object} filters - Filter criteria
 * @param {string} outputPath - Output file path
 * @returns {Promise<string>} Path to generated CSV
 */
export const exportScanHistoryToCSV = async (filters, outputPath) => {
    try {
        const query = {};

        if (filters.verdict) {
            query.result = filters.verdict;
        }
        if (filters.mediaType) {
            query.mediaType = filters.mediaType;
        }
        if (filters.startDate || filters.endDate) {
            query.timestamp = {};
            if (filters.startDate) query.timestamp.$gte = new Date(filters.startDate);
            if (filters.endDate) query.timestamp.$lte = new Date(filters.endDate);
        }

        const scans = await Scan.find(query).sort({ timestamp: -1 }).limit(10000);
        const scanIds = scans.map((s) => s._id);

        return await exportScansToCSV(scanIds, outputPath);
    } catch (error) {
        logger.error(`[EXPORT] Error exporting scan history: ${error.message}`);
        throw error;
    }
};

export default {
    exportScanToPDF,
    exportScansToCSV,
    exportScanHistoryToCSV,
};
